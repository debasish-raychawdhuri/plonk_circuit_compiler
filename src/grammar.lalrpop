use crate::nodes::*;
use std::str::FromStr;

grammar;

// Program with optional public/private variable declarations, function definitions, and expressions
pub Program: Program = {
    <pub_vars:PublicVars?> <priv_vars:PrivateVars?> <funcs:FunctionDefs?> <exprs:ExpressionList> =>
        Program::new(
            pub_vars.unwrap_or_else(|| vec![]),
            priv_vars.unwrap_or_else(|| vec![]),
            funcs.unwrap_or_else(|| vec![]),
            exprs
        ),
};

// Public variable declarations: public: var1, var2, var3
PublicVars: Vec<String> = {
    "public" ":" <vars:VarList> => vars,
};

// Private variable declarations: private: var1, var2, var3
PrivateVars: Vec<String> = {
    "private" ":" <vars:VarList> => vars,
};

// Comma-separated list of variable names
VarList: Vec<String> = {
    <mut list:VarList> "," <var:Identifier> => {
        list.push(var);
        list
    },
    <var:Identifier> => vec![var],
};

// Function definitions
FunctionDefs: Vec<FunctionDefinition> = {
    <mut funcs:FunctionDefs> <func:FunctionDef> => {
        funcs.push(func);
        funcs
    },
    <func:FunctionDef> => vec![func],
};

// Single function definition: fn name(param:type, ...): type { body }
// Body must be a compound expression (braces are mandatory)
FunctionDef: FunctionDefinition = {
    "fn" <name:Identifier> "(" <params:ParamList?> ")" ":" <ret_type:TypeName> <body:CompoundExpression> =>
        FunctionDefinition::new(
            name,
            params.unwrap_or_else(|| vec![]),
            ret_type,
            body
        ),
};

// Parameter list: param1:type1, param2:type2, ...
ParamList: Vec<Parameter> = {
    <mut list:ParamList> "," <param:Param> => {
        list.push(param);
        list
    },
    <param:Param> => vec![param],
};

// Single parameter: name:type
Param: Parameter = {
    <name:Identifier> ":" <param_type:TypeName> =>
        Parameter::new(name, param_type),
};

// Type name (using identifier and converting)
TypeName: Type = {
    <s:Identifier> =>? Type::from_str(&s).map_err(|e| lalrpop_util::ParseError::User { error: e }),
};

ExpressionList: Vec<Expression> = {
    <mut list:ExpressionList> ";" <expr:Expression> => {
        list.push(expr);
        list
    },
    <expr:Expression> => vec![expr],
};

// Expression hierarchy with proper precedence
pub Expression: Expression = {
    OrExpression,
};

// Logical OR
OrExpression: Expression = {
    <left:OrExpression> "||" <right:AndExpression> =>
        Expression::Or(Box::new(left), Box::new(right)),
    AndExpression,
};

// Logical AND
AndExpression: Expression = {
    <left:AndExpression> "&&" <right:ComparisonExpression> =>
        Expression::And(Box::new(left), Box::new(right)),
    ComparisonExpression,
};

NotExpression: Expression = {
    "!" <expr: NotExpression> =>
        Expression::Not(Box::new(expr)),
    Primary,
}

// Comparison operators
ComparisonExpression: Expression = {
    <left:ArithmeticExpression> "==" <right:ArithmeticExpression> =>
        Expression::Equal(Box::new(left), Box::new(right)),
    <left:ArithmeticExpression> "!=" <right:ArithmeticExpression> =>
        Expression::NotEqual(Box::new(left), Box::new(right)),
    <left:ArithmeticExpression> "<" <right:ArithmeticExpression> =>
        Expression::LessThan(Box::new(left), Box::new(right)),
    <left:ArithmeticExpression> "<=" <right:ArithmeticExpression> =>
        Expression::LessThanOrEqual(Box::new(left), Box::new(right)),
    <left:ArithmeticExpression> ">" <right:ArithmeticExpression> =>
        Expression::GreaterThan(Box::new(left), Box::new(right)),
    <left:ArithmeticExpression> ">=" <right:ArithmeticExpression> =>
        Expression::GreaterThanOrEqual(Box::new(left), Box::new(right)),
    ArithmeticExpression,
};

// Arithmetic: Addition and Subtraction
ArithmeticExpression: Expression = {
    <left:ArithmeticExpression> "+" <right:Term> =>
        Expression::Add(Box::new(left), Box::new(right)),
    <left:ArithmeticExpression> "-" <right:Term> =>
        Expression::Subtract(Box::new(left), Box::new(right)),
    Term,
};

// Multiplication and Division
Term: Expression = {
    <left:Term> "*" <right:UnaryNegation> =>
        Expression::Multiply(Box::new(left), Box::new(right)),
    <left:Term> "/" <right:UnaryNegation> =>
        Expression::Divide(Box::new(left), Box::new(right)),
    UnaryNegation,
};

// Unary operators
UnaryNegation: Expression = {
    "-" <expr:UnaryNegation> =>
        Expression::Negate(Box::new(expr)),
    Primary,
};

// Primary expressions
Primary: Expression = {
    "(" <Expression> ")",
    "if" "(" <cond:Expression> ")" <then_expr:Primary> "else" <else_expr:Primary> =>
        Expression::If {
            condition: Box::new(cond),
            then_branch: Box::new(then_expr),
            else_branch: Some(Box::new(else_expr)),
        },
    CompoundExpression,
    FieldLiteral,
    Variable,
    FunctionCall,
};

// Compound expression: { statements; expression }
CompoundExpression: Expression = {
    "{" <stmts:Statements> <expr:Expression> "}" =>
        Expression::Compound {
            statements: stmts,
            expression: Box::new(expr),
        },
    "{" <expr:Expression> "}" =>
        Expression::Compound {
            statements: vec![],
            expression: Box::new(expr),
        },
};

// List of statements (assignments)
Statements: Vec<Statement> = {
    <mut stmts:Statements> <stmt:Statement> ";" => {
        stmts.push(stmt);
        stmts
    },
    <stmt:Statement> ";" => vec![stmt],
};

// Statement (assignment)
Statement: Statement = {
    <var:Identifier> "=" <expr:Expression> =>
        Statement::Assignment {
            variable_name: var,
            value: expr,
        },
};

// Field literal (256-bit hexadecimal number only)
FieldLiteral: Expression = {
    <s:r"0[xX][0-9a-fA-F]+"> => {
        Expression::Literal(FieldLiteral::from_str(s).unwrap())
    },
};

// Variable reference
Variable: Expression = {
    <name:Identifier> => Expression::Variable(name),
};

// Function call
FunctionCall: Expression = {
    <name:Identifier> "(" <args:ArgumentList> ")" =>
        Expression::FunctionCall {
            name,
            arguments: args,
        },
    <name:Identifier> "(" ")" =>
        Expression::FunctionCall {
            name,
            arguments: vec![],
        },
};

ArgumentList: Vec<Expression> = {
    <mut list:ArgumentList> "," <expr:Expression> => {
        list.push(expr);
        list
    },
    <expr:Expression> => vec![expr],
};

// Identifier (variable names, function names)
Identifier: String = {
    <s:r"[a-zA-Z_][a-zA-Z0-9_]*"> => s.to_string(),
};

// Skip whitespace and comments
match {
    r"\s*" => { },  // Skip whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // Skip // comments
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { }, // Skip /* */ comments
    _
}
